#pragma config(Motor, port2, frontRight,	tmotorVex393_MC29, openLoop)
#pragma config(Motor, port3, backRight,		tmotorVex393_MC29, openLoop)
#pragma config(Motor, port4, frontLeft,		tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor, port5, backLeft,		tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor, port6, xRight,		tmotorVex393_MC29, openLoop)
#pragma config(Motor, port7, xLeft,		tmotorVex393_MC29, openLoop, reversed)
//#pragma config(Motor,  port6,           motorClaw,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//All positive motor speed values move that motor foward

task main()
{
	//float minControl = 90;
	//float strafeSpeed = 127/2;
	//float turnSpeed = 127/2;
	//Loop Forever
	//Tank uses Ch 2 and Ch3
	//Strafe use Ch 1
	//Turn in Place use Ch 4

	//Use Probability loop to slowly ram up speed
	float previousSpeedFrontRight = 0;
	float previousSpeedBackRight = 0;
	float previousSpeedFrontLeft = 0;
	float previousSpeedBackLeft = 0;

	float xSpeed = 127;
	float previousSpeedXRight = 0;
	float previousSpeedXLeft = 0;

	float errorCoeff = 4/5;

	while(1 == 1)
	{
		//Remote Control Commands
		float speedFrontRight 	= - vexRT[Ch2] + vexRT[Ch1] + vexRT[Ch4];
		float speedBackRight 	= - vexRT[Ch2] - vexRT[Ch1] + vexRT[Ch4];
		float speedFrontLeft	= - vexRT[Ch3] - vexRT[Ch1] - vexRT[Ch4];
		float speedBackLeft	= - vexRT[Ch3] + vexRT[Ch1] - vexRT[Ch4];
		float speedXRight;
		float speedXLeft;
					
		float speedArray[4] 	= {speedFrontRight, speedBackRight, speedFrontLeft, speedBackLeft};
		float maximum 		= -127;
		int maxPos 		= 0;
		float minimum 		= 127;
		int minPos 		= 0;
		
		//Find max and min speed and which one is each 
		for (int i = 0; i < 4; i++)
		{
			if(speedArray[i] > maximum)
			{
				maximum = speedArray[i];
				maxPos 	= i;
			}
			if(speedArray[i] < minimum)
			{
				minimum = speedArray[i];
				minPos 	= i;
			}
		}
		
		float maxValue = 127;
		float minValue = -127;
		float maxproportion;
		float minproportion;
		
		//If drive speed is greater max or min value then create proportion
		if (maximum > maxValue)
		{
			if (minimum < minValue)
			{
				maxproportion 	= maxValue / speedArray[maxPos];
				minproportion 	= minValue / speedArray[minPos];
				
				if (maxproportion < minproportion)
				{
					speedFrontRight = maxproportion * speedArray[0];
					speedBackRight 	= maxproportion * speedArray[1];
					speedFrontLeft 	= maxproportion * speedArray[2];
					speedBackLeft 	= maxproportion * speedArray[3];
				}
				else
				{
					speedFrontRight = minproportion * speedArray[0];
					speedBackRight 	= minproportion * speedArray[1];
					speedFrontLeft 	= minproportion * speedArray[2];
					speedBackLeft 	= minproportion * speedArray[3];
				}
			}
			else
			{
				maxproportion 	= maxValue / speedArray[maxPos];
				speedFrontRight = maxproportion * speedArray[0];
				speedBackRight 	= maxproportion * speedArray[1];
				speedFrontLeft 	= maxproportion * speedArray[2];
				speedBackLeft 	= maxproportion * speedArray[3];
			}
		}
		else if (minimum < minValue)
		{
			minproportion 	= minValue / speedArray[minPos];
			speedFrontRight = minproportion * speedArray[0];
			speedBackRight 	= minproportion * speedArray[1];
			speedFrontLeft 	= minproportion * speedArray[2];
			speedBackLeft 	= minproportion * speedArray[3];
		}
		
		//Probability factor
		float errorFrontRight 	= errorCoeff * (speedFrontRight - previousSpeedFrontRight);
		float errorBackRight	= errorCoeff * (speedBackRight - previousSpeedBackRight);
		float errorFrontLeft	= errorCoeff * (speedFrontLeft - previousSpeedFrontLeft);
		float errorBackLeft	= errorCoeff * (speedBackLeft - previousSpeedBackLeft);
		float errorXRight;
		float errorXLeft;

		//Swerve Drive with P-Loop
		motor[frontRight] 	= speedFrontRight - errorFrontRight;
		motor[backRight] 	= speedBackRight - errorBackRight;
		motor[frontLeft] 	= speedFrontLeft - errorFrontLeft;
		motor[backLeft] 	= speedBackLeft - errorBackLeft;

		//New previous Speed
		previousSpeedFrontRight = speedFrontRight - errorFrontRight;
		previousSpeedBackRight 	= speedBackRight - errorBackRight;
		previousSpeedFrontLeft	= speedFrontLeft - errorFrontLeft;
		previousSpeedBackLeft	= speedBackLeft - errorBackLeft;

		//X-Lift with P-Loop
		//Lift-up
		if (vexRT[Btn5U] == 1)
		{
			errorXRight 	= errorCoeff * (xSpeed - previousSpeedXRight);
			errorXLeft 	= errorCoeff * (xSpeed - previousSpeedXLeft);

			speedXRight 	= xSpeed - errorXRight;
			speedXLeft 	= xSpeed - errorXLeft;

			motor[xRight]	= speedXRight;
			motor[xLeft] 	= speedXLeft;

			previousSpeedXRight 	= speedXRight;
			previousSpeedXLeft 	= speedXLeft;
		}
		//Lower
		else if (vexRT[Btn5D] == 1)
		{
			errorXRight 	= errorCoeff * (-xSpeed - previousSpeedXRight);
			errorXLeft 	= errorCoeff * (-xSpeed - previousSpeedXLeft);

			speedXRight 	= -xSpeed - errorXRight;
			speedXLeft 	= -xSpeed - errorXLeft;

			motor[xRight]	= speedXRight;
			motor[xLeft] 	= speedXLeft;

			previousSpeedXRight 	= speedXRight;
			previousSpeedXLeft 	= speedXLeft;
		}
		//Stop
		else
		{
			errorXRight 	= errorCoeff * previousSpeedXRight;
			errorXLeft 	= errorCoeff * previousSpeedXLeft;

			speedXRight	= errorXRight;
			speedXLeft	= errorXLeft;

			motor[xRight]	= speedXRight;
			motor[xLeft] 	= speedXLeft;

			previousSpeedXRight	= speedXRight;
			previousSpeedXLeft	= speedXLeft;
		}

		//Wait before running loop again by 50ms
		delay(50);

		/*if(vexRT[Ch1] < - minControl)
		{
			//Strafe left
			//left frontRight forward
			//left backRight backward
			//frontLeft backward
			//backLeft froward
			while (vexRT[Ch1] < - minControl)
			{
				motor[frontRight] 	= strafeSpeed;
				motor[backRight] 		= - strafeSpeed;
				motor[frontLeft] 		= - strafeSpeed;
				motor[backLeft] 		= strafeSpeed;
			}
		}

		if(vexRT[Ch1] > minControl)
		{
			//Strafe right
			while (vexRT[Ch1] > minControl)
			{
				motor[frontRight] 	= - strafeSpeed;
				motor[backRight] 		= strafeSpeed;
				motor[frontLeft] 		= strafeSpeed;
				motor[backLeft] 		= - strafeSpeed;
			}
		}

		if(vexRT[Ch4] > minControl)
		{
			//Turn Left
			while (vexRT[Ch4] > minControl)
			{
				motor[frontRight]			= - turnSpeed;
				motor[backRight]			= - turnSpeed;
				motor[frontLeft]			= turnSpeed;
				motor[backLeft]				= turnSpeed;
			}
		}

		if(vexRT[Ch4] < - minControl)
		{
			//Turn Right
			while (vexRT[Ch4] < - minControl)
			{
				motor[frontRight]			= turnSpeed;
				motor[backRight]			= turnSpeed;
				motor[frontLeft]			= - turnSpeed;
				motor[backLeft]				= - turnSpeed;
			}
		}
	*/
	}
}
